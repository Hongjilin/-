> 此笔记为 本人洪详细学习Git阶段记录笔记,本笔记将记录 较深入的学习git知识点
>
> 如果仅仅简单使用,可只看本笔记的高层命令与分支部分
>
> 但是git知识是一个整体,系统的学习下来在之后使用也能更加得心应手
>
> ​															始于:2021-1-27    截至:`更新中`

# Git详细学习(`更新中`)

## 一、初始化

> 该处是用来提交时当作签名使用的

```
git config --global user.name "我的用户名"
git config --global user.email "我的邮箱"
```

## 二、区域

1. 工作区
2. 暂存区
3. 版本库

## 三、对象详解(底层命令)

### 1、git对象

> 1. key:val 组成的键值对(key是val相应的hash)
>
> ​		键值对在git内部是blob类型(git特有)
>
> 2. 存储数据文件内容,也称为数据对象

##### ① 直接写入git对象方法与读取(存入".git/objects")

```shell
#将打印内容写入对象(git数据库)并且返回其相应哈希值
echo "写入的对象内容" | git hash-object -w --stdin 
#读取内容并不能直接cat读取,因为git存入时已经加密,需要如下代码 -p:内容  -t:类型
git cat-file -p 存入对象的哈希值(此值可以由上一步得到) 
#将文件写入git对象,即我们常见的版本控制中出现的
git hash-object -w ./test.txt
#查看Git存储的数据  返回其文件夹内的所有哈希文件
find .git/objects -type f 
```

### 2、树对象

> 树对象是存储键值 作用为控制版本,如我们的版本前回退 就是在操作这个对象的(指向改变)
>
> 作用就是生成快照
>
> 这个也是git的必杀特性,因为他的切换分支与版本都很快 只是指针切换

#### 构建树对象

> 我们可以通过 update-index , write-tree , read-tree 等命令来构建树对象并且塞到暂存区

##### ① 利用 `update-index` 命令 创建暂存区

>利用 `update-index` 命令 为test.txt文件的首个版本创建一个暂存区,并通过`write-tree`命令生成树对象

```shell
#1生成一个树对象
git update-index --add --cacheinfo 100664(文件状态码:普通文件) 哈希值 对应文件名
#生成快照(树对象)
git write-tree
#2 将第一个树对象加入第二个树对象,使其成为新的树对象
git read-tree -prefix=bak 哈希值(树对象的)  
git write-tree
```

##### ②查看暂存区当前样子

```shell
git ls-files -s
```

### 3、提交对象

> 1. 通过上述两个对象操作后,你会发现你已经生成了不同项目的快照,但是问题是:如果想重用这些快照,你必须记住所有三个 SHA-1(快照)哈希值 .但是,你也完全不知道是谁保存了这些快照,在什么时刻保存的,以及为什么保存这些快照.而以上这些,正是提交对象(commit object)能为你保存的基本信息
>2. 我们可以通过调用commit-tree命令创建一个提交对象,为此需要指定一个树对象的SHA-1值,为此需要指定一个树对象的SHA-1值 , 以及该提交的父提交对象(如果有的话,第一次将暂存区做快照就没有父对象)
> 3. 真正的一个版本其实就是提交对象

##### ①创建提交对象

```shell
echo "first commit" |git commit-tree 树对象的哈希值
```

②指定一个树对象的SHA-1值 , 以及该提交的父提交对象

```shell
echo "second commit" | git commit-tree 提交的树对象哈希值 -p 父亲树对象哈希值
```

## 四、高层命令

### 1、git add  .

>1. 会将工作目录的修改,保存成git对象 `先到版本库,再到暂存区`,而不是直接到暂存区
>
>2. 在工作目录修改几个文件,就会生成几个git对象(一个文件对应一个git文件)
>
>3. 同一个文件,每次修改再add的时候都会生成一个新的git对象,是`增量`而不是覆盖
>4. 所以说git是绝对安全的,就算我只存到暂存区没有提交 git也会给我保存
>5. 只有后面提交的时候,才会根据暂存区内容给我生成树对象并存入版本区,然后加上我们的提交信息,才生成提交对象存入版本库

```shell
#相当于以下两个命令集合
git hash-object -w 文件名(修改了多少个工作目录中的文件,就要被执行几次)
git update-index ...
```

### 2、 git  commit -m "注释内容"

> 将暂存区提交到版本库

```shell
git write-tree
git commit-tree
```

> 跳过暂存区存入(之前add过的,直接提交)

```shell
git commit -a -m ""
```

### 3、git init 

> 初始化仓库 初始化后,在当前目录下出现一个名为.git的文件夹

### 4、git status

> 查看文件的状态

### 5、git diff

1. 当前做的那些更新没有暂存?

    命令:`git diff`(不加参数直接输入git diff)

2. 有哪些更新已经暂存起来准备好了下次提交

   命令:`git diff --cached`或者`git diff --staged(1.6.1以上版本)`

### 6、git log

> 1. `git log`(不带参数)
>
>    `空格键`往下翻页 `b`向上翻页 `q`退出日志查阅
>
> 2. git log --oneline 
>
>    将日志信息拍成一行显示
>
> 3. git reflog
>
>    所有的日志信息
>    
> 4. git log --oneline --decorate --graph --all
>
>    查看所有的分支信息命令

### 7、git rm 

> 删除工作目录对应的文件,再将修改添加到暂存区(如同删除后给你用了 `git add 文件名`)

```shell
#删除命令
git rm 文件名 
#直接提交修改,因为rm命令帮你提交到暂存区了
git commit -m "xxx"
```

### 8、git mv

>将工作目录中的文件进行重命名,再将修改添加到暂存区

```shell
git mv 原文件名  新文件名
```



## 五、配别名

> Git并不会在你输入部分命令时自动推断出你想要的命令,如果不想每次都输入完整的Git命令,可以通过git config 文件来轻松为每一个命令设置一个别名

```shell
git config --global alias.自定义命令 " `git` 命令后面的指令 "
#如配置查看分支信息 "git log --oneline --decorate --graph --all"
git config --global alias.logbranch "log --oneline --decorate --graph --all"
#配置切换分支
git config --global alias.co checkout
#使用方式
git logbranch
```

## 六、分支

> 1. 前言:
>
>    几乎所有的版本控制西永都以某种形式支持分支.使用分支意味着你可以把你的工作从开发主线上分离开来,以免影响开发主线.在很多版本控制系统中,这是略微低效的过程--常常需要完全创建一个源代码目录的副本,对于大项目来说,这会耗费很多时间,而Git的分支模型极其的高校轻量,是Git的必杀特性,也正因为这一特性,是的Git从众多版本控制系统中脱颖而出
>
> 2. 分支的本质:
>
>    `Git的分支,其实本质上仅仅是指向提交对象的可变指针`.Git的默认分支名字是master,在多次提交后,你其实已经有一个指向最后那个提交对象的master分支.他会在每次的提交操作中自动向前
>
>    注意:Git的"master"分支并不是一个特殊分支.她就跟其他分支完全没有区别.之所以几乎每个仓库都有master分支,是因为`git init`命令默认创建它,并且大多数人懒得区改动它
>
> 3. 分支的原理:
>
>    1. `.git/refs`目录中保存了分支及其对应的提交对象
>
>    2. 当运行类似于`git branch (branchname)`这样的命令时,Git会取得当前所在分支最新提交对应的SHA-1值,并将其加入你想要创建的任何新分支中
>
>    3. 当你执行`git branch (branchname)`时,Git如何知道最新提交的SHA-1值呢?答案是HEAD文件
>
>       `HEAD文件`是一个符号引用(stmbolic reference),指向目前所在的分支.所谓符号医用,意味着它并不像普通引用那样包含一个SHA-1值.它时一个指向其他引用的指针



### 1、git branch 

> 1. git branch(不加参数)
>
>    显示所有分支信息
>
> 2. git branch 分支名
>
>    创建分支
>
> 3. git branch -v
>
>    查看每一个分支最后一次提交
>
> 4. git branch -d(-D强制删除) 分支名
>
>    删除分支,小d需要你这个分支是干净的才能删除(如已合并)
>
> 5. git branch --merged 
>
>    查看那些分支已经合并到当前分支
>
>    在这个列表中的分支名字前没有*号的分支通常可以使用`git branch -d` 删除掉
>
> 6. git branch --no-merged
>
>    查看所有包含未合并工作的分支
>
>    尝试使用`git branch -d`命令删除在这个列表中的分支时会失败,如果真的想要删除分支并丢掉哪些工作,可以使用`-D` 选项爱强制删除它
>
> 7. git log --oneline --decorate --graph --all
>
>    查看所有的分支信息命令
>
> 8. git branch 分支名 commitHash
>
>    新建一个分支,并且使分支指向对应的提交对象(版本穿梭`可以替代撤销与重置`)

### 2、git checkout 分支名

> 切换分支
>
> 它会动三个地方:HEAD(指针) 暂存区 工作目录

> 1. `注意`:分支切换会改变你工作目录中的文件,所以在切换分支时,一定要注意你的工作目录里的文件会被改变,如果时切换到一个比较旧的分支,你的工作目录会回复到该分支最后一次提交的样子,如果Git不能干净利落的完成这个任务,它将禁止切换分支
>
> 2. `坑`:在切换分支时, 如果当前分支上由未暂存的修改(`第一次`) 或者 有未提交的暂存`(第一次`) 分支可以切换成功,但是这种操作可能会污染其他分支
>
>    ps:`第一次`--当前分支如果已经提交过一次,将不让你切换,但是第一次没有提交过,git会帮你保存文件 但是它并不知道新增修改是属于哪个分支,所以会带回当前分支
>
> 3. 最佳操作方式:`每次在切换分支前,需要提交一下当前分支(先使用status查看状态)`

### 3、git checkout -b "新的分支名"

> 创建并进入该分支,类似于上面两个命令集合

### 4、模拟实战流程

>1. 需要解决主程序的的一个小BUG,所以使用`git  checkout -b "iss_bug"`新建分支并在这个分支进行bug调修
>
>2. 当你再`iss_bug`分支上开发到一半,这时,在主程序发现了一个紧急BUG需要你放下这个重要性为次要的bug进行修改.你老板都给你打了紧急电话,所以你需要先将写到一半的bug进行保存提交(`commit`提交或者储存  到暂存区,并不是提交合并到主分支,也不是push提交),确定status是干净的时候,切换回主分支,再用第一步的方法创建`hot_bug`分支(这时候`hit_bug`的版本是master没有进行`iss_bug`调修的版本),进行修复
>
>3. 当你将紧急bug修复后,进行提交,确定status干净后切换回master分支,进行合并:代码如下
>
>   ```shell
>   git checkout master
>   git merge hit_bug
>   ```
>
>4. 修改完后再查看status(这是个好习惯,防止偶尔记忆混淆造成不必要的麻烦),再切换至普通bug分支`iss_bug`进行修改,成功后切换回去合并
>
>5. 如果出现冲突,去出现冲突的文件手动修改(决定保留那部分代码),再进行`git add`表示冲突解决,在进行提交 

## 七、存储

> 1. 需求背景:
>
>    有时,当你在项目的一部分上已经工作了一段时间后,所有东西都进入了混乱的状态,而这时你想要切换到另一个分支做一点别的事情.问题是,你不想仅仅因为过会儿回到这一点而做了一半的工作创建一次提交
>
> 2. 解决:
>
>    针对这个问题的答案是 `git stash` 命令(当然,直接提交`commit`也可以,这个是用来不想生成提交对象而用)
>
> 3. 原理:
>
>    git切换分支之所以保留你的未提交的修改文件,是因为它不想你因为误操作使得之前代码报废所以会当你status不干净时组织你切换分支(`ps`:如果是第一次创建的文件没有追踪过,它不认识是属于那份分支将会带到你切换后的分支造成污染),
>
>    而你将其保存到栈上(`ps`:换句话说将这部分内容抽取到一个类似共有的栈上,你在哪个分支都能够通过命令取到),git就知道你这个内容已经储存并不会造成切换分支使得你写的代码丢失,便不会阻止你切换分支或者切换带文件污染分支

### 1、git stash

> `git stash`命令会将未完成的修改保存到一个栈上,而你可以在任何时候重新应用这些改动(`git stash apply`)

### 2、git stash list 

> 查看存储

### 3、git stash pop

> 来应用储藏然后立即从栈上扔掉它 `这是最推荐的使用`

#### 4、git stash apply stash@{2}

> 如果不指定一个储藏,git认为指定栈顶`不常用`

### 5、git stash drop "储藏的名字"

>加上要储藏的名字移除他 `不常用`

## 八、撤销与重置(`理解即可`)

> 特别是重置部分理解即可,撤销尽量可以掌握

### 撤销

#### 1、git commit --amend

> 1. 这个命令会将暂存区中的文件提交,修订提交(`不是撤销而是修订覆盖`)
>
> 2. 如果自上次提交以来你还未做任何修改(如:在上次提交后马上执行此命令),那么快照会保持不变,而你修改的只是提交信息
>
> 3. 如果你提交后发现忘记了暂存某些需要的修改,可以像下面这样操作
>
>    ```shell
>    git commit -m "错误的注释" #或者commit了错误的修改
>    git add "文件名或者."  #重新add正确的文件
>    git commit --amend		#进行重新提交
>    ```
>
>    最终你只会有一个提交 (第二次提交将会替代第一次提交)
>
> 4. 可以改提交的文件与注释

#### 2、git reset 

>命令:`git reset HEAD 文件名`
>
>作用:将文件从`暂存区中撤回`到工作目录中

#### 3、git checkout

>是的,你没看错,这个是切换分支的命令,但是他也能用来`撤销文件修改`
>
>命令:`git checkout --文件名`
>
>将在工作目录中对文件的修改撤销
>
>`注意`:这是一个危险的命令,这很重要.你对那个文件做的任何修改都会消失--你只是拷贝了另一个文件(原来版本的文件)来覆盖它.除非你确实秦楚不想要那个文件了,否则不要使用这个命令

### 重置reset

> 注意:`--hard`标记是`reset`命令唯一的`危险用法`,也是Git真正的销毁数据的几个仅有操作之一.其他任何形式的`reset`调用都可以轻松撤销,但是`--hard`选项不能,因为它强制覆盖了工作目录中的文件.
>
> 如在这种特殊情况:我们的Git数据库中的一个提交内还留有该文件的几个版本,我们可以通过`reflog`来找回它,但若是该文件还未提交,Git仍会覆盖他导致它无法恢复

#### reset三部曲

>第一部:git reset --soft HEAD~(等于之前的--amend)
>
>​	移动HEAD (但带着分支一起移动,与checkout不同(它只动HEAD))
>
>第二部:git reset --mixed HEAD~
>
>​	移动HEAD 并且动了了暂存区
>
>第三部:git reset --hard HEAD~
>
>​	移动HEAD 并且动了了暂存区 动了工作目录



​		