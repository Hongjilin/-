# JAVA笔记总纲

# ------------------==(Java壹)==---------------------

# 对象与类相关概念 =>day7_22观阅视频补充

## 一.java中类与对象的关系与区别

######    1.什么是类？

类就是具备某些共同特征的实体的集合，它是一种抽象的数据类型，它是对所具有相同特征实体的抽象。在面向对象的程序设计语言中，类是对一类“事物”的属性与行为的抽象。

######    2.什么是对象？

对象就是一个真实世界中的实体，对象与实体是一一对应关系的，意思就是现实世界的每一个实体都是一个对象，所以对象是一个具体的概念。

######    3.类是对象的一个集合，对象是类的实例。

## 二.面向对象(OO)的含义与优点

######    1.面向对象(OO)的优点=>

1. 与人类的思维习惯一致:把人类解决问题的思维过程转变为程序能够理解的过程
2. 信息隐藏,提高了程序的可维护性和安全性:
     1. 封装实现了模块化和信息隐藏
     2. 封装使得在对象外部不能随意访问对象的属性和方法
3. 提高了程序的可重用性
     1. 一个类乐意创建多个对象实例,增加了重用性

######      2.OO的分类与含义

-  OOP:面向对象的变成
-  OOA:面向对象的分析
-  OOD:面向对象的设计

## 三.成员变量与局部变量

##### 		1.变量优先级判断

​				a. 范围越小,优先级越高

​				b. 越晚出现,优先级越高

#####   		2.成员变量与局部变量的区别

###### 				a.作用域不同=>

​						\*  局部变量的作用域仅限与定义它的方法

​						\* 成员变量的作用域在整个类内部都是可见的

###### 				b.初始值不同=>

​						\* java会给成员变量一个初始值

​						\* java不会给局部变量赋予初始值

######    			c.在同一个方法中,不允许有同名局部变量;在不同方法中可以有同名方法

###### 				d.两类变量同名时,局部变量具有更高优先级

## 四.JavaDoc注释(生成注释文档)

1. ###### 生成注释(两个**号是JavaDoc,一个\*号是多行注释)

```
/**+回车
```

```java
/**
 * @author 洪
 * @version 1.0
 */
```

2. ###### 导出以及查看文档

 3.    右键项目导出(Export)=>java=>javadoc=>选择导出位置

       2. 在生成文件中查看index.html

​					

## 五.本章总结

#### (1).对象与类总结=>

1. 对象是用来描述客观事物的一个实体

2. 类定义了对象将会拥有的特征(属性)和行为(方法)

3. 类是对象的类型,对象是类的实例

4. 使用类的步骤
 5. 定义类:使用关键字class
     2. 创建类的对象:使用关键字new
     3. 使用类的属性与方法:使用"."等操作符

#### (2).类的无参方法=>

###### 	1.定义类的方法必须包括:

      1. 方法的名称
      2. 方法返回值的类型
      3. 方法的主体

######      2.调用类方法的两种形式:

      1. 同一个类中的方法,直接使用"==方法名()=="调用
      2. 不同类的方法,先==创建对象==,在使用=="对象名.方法名()"==调用

######      3.成员变量和局部变量的不同点:

1.    作用域不同:

            1.    成员变量在整个类都是可见的
            2.    局部变量仅限于定义它的方法内

2. 初始值不同:

     	   1.    java会为成员变量赋予初值
     	   2.    java不会为局部变量赋予初值

3.    在同一个方法中,不允许有同名局部变量;在不同方法中可以有同名方法

      两类变量同名时,局部变量具有更高优先级

######    4.注释符:

1.  单行注释://
2.  多行注释/* */
3.  JavaDoc注释/** */



##### (3).类的带参方法:

   1.    带参方法定义的一般形式:

         ```
         <访问修饰符> 返回类型 <方法名> (<形式参数>){
         			//方法的主体
         }
         ```

2. 参数的概念:

 3.    形参是在定义方法时对参数的称呼

       2. 实参是在调用时传递给方法的实际的值

4. 调用带参方法时要求实参与形参要匹配

## 六.遗留问题及解决

###### 1.Srring明明是引用类型参数,但是为什么没有改变









# ------------------==(Java贰)==---------------------

# 字符串String =>day7_23笔记总结

## 一.字符串(String)类:

##### 		1.字符串用途:

​				a.用于字符串常量,也就是说字符串的值不会改变

##### 		2. String代码解释=>

```java
/*1.赋值时相当于执行一次new操作*/
String name=new  String()
name="hong"  
=>name=new String("hong")

/*2.当赋值为""时,有创建空间,只是里面没有值*/
String name="";
=>String name= new String("")

/*3.赋值为null时相当于没有创建空间*/
String name=null;=>String name;

/*4.引用类型判断时,通常都要先判断是否为空再判断空字符串*/
if(name!=null&&name.equal(""))
```

##### 		3.字符串主要构造函数方法=>

| 方法                                          | 说明                                                         |
| :-------------------------------------------- | :----------------------------------------------------------- |
| String()                                      | 生成一个空串                                                 |
| String(String  value)                         | 用已知串生成一个串对象                                       |
| String(char value[])                          | 用字符数组生成一个串对象                                     |
| String(char value[] , int offset , int count) | 用字符数组value的offset位置开始的count个字符,建立一个字符串对象,之后并不影响原来的字符串数组 |
| String(StringBuffer  value)                   | 用已经存在的StringBuffer对象初始化String对象                 |
|                                               |                                                              |



##### 4.字符串比较方法=>

1.   equals()=>  检查组成字符串内容的字符是否一致
2.   "=="符号比较=>  判断两个字符串在内存中的首地址,即判断是否是同一个字符串对象
3.   equalslgnoreCase()方法=>  忽略大小写比较
4.   toLowerCase()方法=>  将双方变为小写字符比较
5.   toUpperCase()方法=>  将双方变为大写字符比较
6.   compareTo()方法=> 按字典顺序比较两个字符串

##### 5.字符串连接方法=>

1.   使用"+"
2.   使用String类的concat()方法

##### 6.字符串常用提取方法=>

| 方法                                                         | 说明                                                         |
| ------------------------------------------------------------ | :----------------------------------------------------------- |
| public int **indexOf**(int ch)<br />public int **indexOf**(String value) | 搜索第一个出现的字符ch(或字符串value)                        |
| public int **lastIndexOf**(int ch)<br />public int **lastIndexOf**(String value) | 搜索最后一个出现的字符ch(或字符串value)                      |
| public char **charAt**(int index)                            | 查找字符串的第index个字符                                    |
| public String **substring**(int index)                       | 提取从位置索引开始的字符串部分                               |
| public String **substring**(int beginindex,int endindex)     | 提取beginindex和endindex之间的字符串部分                     |
| public String **trim**()                                     | 返回一个前后不含任何空格的调用字符串的副本                   |
| public boolean **startWith**(String prefix)<br />public boolean **endWith**(String suffix) | 测试字符串的起始字符串和结束字符串(验证开头和结尾是否为输入的字符出啊) |
| public String **replace**(char oldChar , char new Char)      | 字符串替换                                                   |
| String.**split**(char value)                                 | 字符串拆分                                                   |





## 二.StringBuffer类(String增强版)

##### 	1.StringBuffer用途

​		a.用于字符串变量,也就是说字符串的值可以改变

##### 	2.StringBuffer的代码声明与使用=>

```java
/*1.StringBuffer的声明*/
StringBuffer sb=new StringBuffer();//创建空StringBuffer对象
StringBuffer sb=new StringBuffer(5);//创建长度为5StringBuffer对象
StringBuffer sb=new StringBuffer("hello World");//创建一个变量存储字符串"hello World"

/*2.StringBuffer的使用*/
sb.toString();//转化为String类型
sb.append("**");//追加字符串
```

##### 	3.StringBuffer类的常用方法=>

| 方法                                                         | 说明                                                      |
| ------------------------------------------------------------ | --------------------------------------------------------- |
| **setLength**(int newlength)                                 | 重新设置字符串的长度,新串会为旧串的截余(常用来截取前几位) |
| **setCharAt**(int index, char ch)                            | 重设指定位置的字符串                                      |
| **append**(Object obj)                                       | 将指定对象转化为字符串添加到原串尾部                      |
| **insert**(int offset ,Object obj)                           | 将指定对象转换为字符串,然后插入到从offset开始的位置       |
| **capacity**                                                 | 求字符串容量(不等于字符串长度)                            |
| **deleteCharAt**( int index)<br />**delete**(int start,int end) | 删除字符                                                  |
| **reverse()**                                                | 翻转字符串                                                |
|                                                              |                                                           |
|                                                              |                                                           |





















# ---------------==(叁)==------------------

# 对象和封装=>day7_30笔记总结

## 一.封装

##### 	1.封装的概念

> 在面向对象程式设计方法中，封装（英语：Encapsulation）是指一种将抽象性函式接口的实现细节部分包	   		装、隐藏起来的方法。
>
> 封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。
>
> 要访问该类的代码和数据，必须通过严格的接口控制。
>
> 封装最主要的功能在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段。
>
> 适当的封装可以让程式码更容易理解与维护，也加强了程式码的安全性。



##### 	2.封装的优点

			1. 良好的封装能够减少耦合。
	
	  			2. 类内部的结构可以自由修改。
	  			3. 可以对成员变量进行更精确的控制。
	  			4. 隐藏信息，实现细节。



## 二.final的使用

##### 	1.修饰类

当用final去修饰一个类的时候，表示这个类不能被继承。注意：

a. 被final修饰的类，final类中的成员变量可以根据自己的实际需要设计为fianl。

b. final类中的成员方法都会被隐式的指定为final方法。说明：在自己设计一个类的时候，要想好这个类将来是否			会被继承，如果可以被继承，则该类不能使用fianl修饰，在这里呢，一般来说工具类我们往往都会设计成为一			个fianl类。在JDK中，被设计为final类的有String、System等。代码：



![img](https://ss1.baidu.com/6ONXsjip0QIZ8tyhnq/it/u=2411423419,2520809892&fm=173&app=25&f=JPEG?w=640&h=360&s=A5F26D32073A64294451C0DA0000C0B3)



##### 2.修饰方法

被final修饰的方法不能被重写。注意：

a. 一个类的private方法会隐式的被指定为final方法。

b. 如果父类中有final修饰的方法，那么子类不能去重写。

**代码：**



![img](https://ss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=876634331,3528497804&fm=173&app=25&f=JPEG?w=640&h=336&s=C6D0ED32877A44280ED888DE0000C0B3)

##### **3. 修饰成员变量**

a. 必须要赋初始值，而且是只能初始化一次。

**代码：**



![img](https://ss1.baidu.com/6ONXsjip0QIZ8tyhnq/it/u=433607551,3063868730&fm=173&app=25&f=JPEG?w=640&h=360&s=E952ED1A053E64291CF889DA020090B3)

##### 4.**修饰成员变量**

a. 必须初始化值。

b. 被fianl修饰的成员变量赋值，有两种方式：1、直接赋值 2、全部在构造方法中赋初值。

c. 如果修饰的成员变量是基本类型，则表示这个变量的值不能改变。

d. 如果修饰的成员变量是一个引用类型，则是说这个引用的地址的值不能修改，但是这个引用所指向的对象里面的内容还是可以改变的。

**代码：**



![img](https://ss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=682519727,1257936163&fm=173&app=25&f=JPEG?w=640&h=336&s=C6D2ED3A0F2255205EE194DA0000D0B1)



## 三.Static(静态关键字)的使用

##### 	1.static的作用:

static的主要作用在于创建独立于具体对象的域变量或者方法

##### 	2.static要解决什么问题？

我们知道，当我们通过new关键字去创建对象的时候，那么数据的存储空间才会被分配，类中的成员方法才能被对象		所使用。但是呢有两种特殊的情况：

1. 我们通过new关键字创建的对象共享同一个资源，而不是说每个对象都拥有自己的数据，或者说根本就不需要去创建对象，这个资源和对象之间是没有关系的。
2. 希望某个方法不与包含它的类的任何对象联系在一起。总结下来就是说：**即使没有创建对象，也能使用属性和调用方法**，static目的就是在于解决这个问题。

#####     3.static特点=>

1. static可以修饰变量，方法
2. 被static修饰的变量或者方法是独立于该类的任何对象，也就是说，这些变量和方法不属于任何一个实例对象，而是被类的实例对象所共享。
3. 在类被加载的时候，就会去加载被static修饰的部分。
4. 被static修饰的变量或者方法是优先于对象存在的，也就是说当一个类加载完毕之后，即便没有创建对象，也可以去访问。

##### 4.**static静态变量**

> 被static修饰的成员变量叫做静态变量，也叫做类变量，说明这个变量是属于这个类的，而不是属于是对象，没有被static修饰的成员变量叫做实例变量，说明这个变量是属于某个具体的对象的。

##### 5.**静态变量和实例变量的区别**

1. 实例变量：每次创建对象，都会为每个对象分配成员变量内存空间，实例变量是属于实例对象的，**在内存中，创建几次对象，就有几份成员变量**。

   2.静态变量：静态变量由于不属于任何实例对象，是属于类的，所以在内存中只会有一份，在类的加载过程中，JVM为静态变量分配一次内存空间

##### 6.**static静态方法**

> 被static修饰的方法也叫做静态方法，因为对于静态方法来说是不属于任何实例对象的，那么就是说在静态方法内部是不能使用this的，因为既然不属于任何对象，那么就更谈不上this了。

##### 7.**static使用注意事项**

1. 在静态方法中没有this关键字因为静态是随着类的加载而加载，而this是随着对象的创建而存在的。
2. 静态比对象优先存在。静态可以访问静态的，但是静态不能访问非静态的。
3. 非静态的可以去访问静态的

##### 8.总结

1. 静态只能访问静态。
2. 非静态既可以访问非静态的，也可以访问静态的。



## 四.构造函数单例模式(提升知识点)

### 	1、概述

单例模式的**定义**就是**确保某一个类只有一个实例，并且提供一个全局访问点。**属于设计模式三大类中的**`创建型模式`**。
 单例模式具有典型的三个**特点**：

- 只有一个实例。
- 自我实例化。
- 提供全局访问点。

其**UML**结构图非常简单，就只有一个类，如下图：

![img](https:////upload-images.jianshu.io/upload_images/10149931-8d107c95af96efb0.png?imageMogr2/auto-orient/strip|imageView2/2/w/576/format/webp)



### 2、优缺点

- **优点**：由于单例模式只生成了一个实例，所以能够节约系统资源，减少性能开销，提高系统效率，同时也能够严格控制客户对它的访问。
- **缺点**：也正是因为系统中只有一个实例，这样就导致了单例类的职责过重，违背了“单一职责原则”，同时也没有抽象类，这样扩展起来有一定的困难。

### 3、常见实现方式

常见的单例模式实现方式有五种：`饿汉式`、`懒汉式`、`双重检测锁式`、`静态内部类式`和`枚举单例`。而在这五种方式中**`饿汉式`**和**`懒汉式`**又最为常见。下面将一一列举这五种方式的实现方法：

- **饿汉式**：**线程安全**，调用效率高。但是不能延时加载。示例：



```java
public class SingletonDemo1 {

    //线程安全的
    //类初始化时，立即加载这个对象
    private static SingletonDemo1 instance = new SingletonDemo1();

    private SingletonDemo1() {
    }

    //方法没有加同步块，所以它效率高
    public static SingletonDemo1 getInstance() {
        return instance;
    }
}
```

由于该模式在加载类的时候对象就已经创建了，所以加载类的速度比较慢，但是获取对象的速度比较快，且是**线程安全**的。

- **懒汉式**：**线程不安全**。示例：



```java
public class SingletonDemo2 {

    //线程不安全的

    private static SingletonDemo2 instance = null;

    private SingletonDemo2() {
    }

    //运行时加载对象
    public static SingletonDemo2 getInstance() {
        if (instance == null) {
            instance = new SingletonDemo2();
        }
        return instance;
    }

}
```

由于该模式是在运行时加载对象的，所以加载类比较快，但是对象的获取速度相对较慢，且**线程不安全**。**如果想要线程安全的话可以加上`synchronized`关键字**，但是这样会付出惨重的效率代价。

- **懒汉式（双重同步锁）**



```java
public class SingletonDemo3 {

    private static volatile SingletonDemo3 instance = null;

    private SingletonDemo3() {
    }

    //运行时加载对象
    public static SingletonDemo3 getInstance() {
        if (instance == null) {
            synchronized(SingletonDemo3.class){
                 if(instance == null){
                     instance = new SingletonDemo3();
                 }
            }
        }
        return instance;
    }

}
```

```java
//调用
Book book=Book.getInfo();
```

由于剩下的几种实现方式暂没有接触过，可暂时参考[一张图搞定Java设计模式，单例模式](https://links.jianshu.com/go?to=https%3A%2F%2Fbaijiahao.baidu.com%2Fs%3Fid%3D1570148907639754%26wfr%3Dspider%26for%3Dpc)。

**注**：注意单例模式所属类的**构造方法是私有的**，所以单例类是**不能被继承的**。

### 4、常见应用场景

- 网站计数器。
- 项目中用于读取配置文件的类。
- 数据库连接池。因为数据库连接池是一种数据库资源。
- Spring中，每个`Bean`默认都是单例的，这样便于Spring容器进行管理。
- Servlet中`Application`
- Windows中任务管理器，回收站。
  等等。

> aothor  洪吉林 