# #此文件为方便gitee网站观阅使用专门创建

> 此笔记文件于某一时间复制至此,容易存在更新不及时问题,建议观看同级目录下的笔记文件
>
> 只截取了上方`A_ES6知识补充与所遇问题`部分笔记的部分知识点至此,方便网站阅读

>此笔记是查阅及整理完es6常用api笔记后的补充笔记,也是后续会进行补充的笔记
>
>将记录开发过程或者学习过程遇到的需要补充的知识点或者没遇过的值得mark的场景及解决
>
>本人笔记地址分享:[`全部笔记`](https://gitee.com/hongjilin/hongs-study-notes)
>

# #目录

>[TOC]

# A_ES6知识补充与所遇问题

## 一、补充知识

### Ⅰ-ES6小知识点:`连续赋值解构`+重命名

>```js
>	let obj = {a:{b:1}}
>	const {a} = obj; //传统解构赋值
>	const {a:{b}} = obj; //连续解构赋值
>	const {a:{b:value}} = obj; //连续解构赋值+重命名
>```

### Ⅱ-多个连续箭头函数-`高阶箭头函数、柯里化`

#### 1、`高阶函数`

>1. 所谓高阶函数，就是一个函数就可以接收另一个函数作为参数，或者是返回一个函数-->常见的高阶函数有map、reduce、filter、sort等
>
>   ```js
>   var ADD =function add(a) {
>    return function(b) {
>     return a+b
>    }
>   }
>    调用：ADD(2)(3)即可获得结果
>   ```
>
>2. map
>
>   ```js
>   map接受一个函数作为参数，不改变原来的数组，只是返回一个全新的数组
>   var arr = [1,2,3,4,5]
>    var arr1 = arr.map(item => item = 2)// 输出[1,1,1,1,1]
>   ```
>
>3. reduce
>
>   ```js
>   reduce也是返回一个全新的数组。reduce接受一个函数作为参数，这个函数要有两个形参，代表数组中的前两项，reduce会将这个函数的结果与数组中的第三项再次组成这个函数的两个形参以此类推进行累积操作
>   var arr = [1,2,3,4,5]
>   var arr2 = arr.reduce((a,b)=> a+b)
>   console.log(arr2) // 15
>   ```
>
>4. filter
>
>   ```js
>   filter返回过滤后的数组。filter也接收一个函数作为参数，这个函数将作用于数组中的每个元素，根据该函数每次执行后返回的布尔值来保留结果，如果是true就保留，如果是false就过滤掉（这点与map要区分）
>   var arr = [1,2,3,4,5]
>    var arr3 = arr.filter(item => item % 2 == 0)
>   console.log(arr3)// [2,4]
>   ```

#### 2、从 ES6 高阶箭头函数理解函数柯里化

>1. 首先看到了这样的一个例子：
>
>   ```js
>   let add = a => b => a + b
>   ```
>
>2. 以上是一个很简单的相加函数，把它转化成 ES5 的写法如下
>
>   ```js
>   function add(a) {
>       return function(b) {
>           return a + b
>       }
>   }
>    
>   var add3 = add(3) //add3表示一个指向函数的变量 可以当成函数调用名来用
>   add3(4) === 3 + 4 //true
>   ```
>
>3. 再简化一下，可以写成如下形式：
>
>   ```js
>   let add = function(a) {
>       var param = a;
>       var innerFun = function(b) {
>           return param + b;
>       }
>       return innerFun;
>   }
>   ```
>
>4. 虽然好像没什么意义，但是很显然上述使用了闭包，而且该函数的返回值是一个函数。其实，这就是`高阶函数的定义：以函数为参数或者返回值是函数的函数。`
>
>   ![image-20210415160945789](A_ES6知识补充与所遇问题中的图片/image-20210415160945789.png)

#### 3、柯里化

>1. 图例:
>
>   ![image-20210415161137977](A_ES6知识补充与所遇问题中的图片/image-20210415161137977.png)
>
>2. 关键就是`理解柯里化`，其实可以把它理解成，柯里化后，`将第一个参数变量存在函数里面了(闭包)`，然后本来需要n个参数的函数可以变成只需要剩下的（n - 1个）参数就可以调用，比如
>
>   ```js
>   let add = x => y => x + y
>   let add2 = add(2)
>   -*----------------------------------
>   本来完成 add 这个操作，应该是这样调用
>   let add = (x, y) => x + y
>   add(2,3)
>   ----------------------------------
>   1. 而现在 add2 函数完成同样操作只需要一个参数，这在函数式编程中广泛应用。
>   let add = x => y => x + y
>   let add2 = add(2)
>   2.详细解释一下，就是 add2 函数 等价于 有了 x 这个闭包变量的 y => x + y 函数,并且此时 x = 2，所以此时调用
>   add2(3) === 2 + 3
>   ```

#### 4、总结

>1. 如果是`a => b => c => {xxx}`这种多次柯里化的,如何理解
>
>   理解:前` n - 1 `次调用，其实是提前将参数传递进去，并没有调用最内层函数体，最后一次调用才会调用最内层函数体，并返回最内层函数体的返回值
>
>2. 结合上文可知，这里的多个连续箭头（无论俩个箭头函数三个及以上）函数连在一起 就是在柯里化。所以连续箭头函数就是多次柯里化函数的 es6 写法。
>
>3. `调用特点`:let test = a => b => c => {xxx}
>
>   比如对于上面的 `test` 函数，它有 3 个箭头， 这个函数要被调用 3 次 `test(a)(b)(c)`，前两次调用只是在传递参数，只有最后依次调用才会返回 `{xxx}` 代码段的返回值，并且在 `{xxx}` 代码段中可以调用 a,b,c

## 二、问题与解决

### Ⅰ-`import`动态导入图片时报错

>1. 问题一:使用`import a from "@/img/"+url`时报错
>
>   解决:使用const a = require(`@/img/${文件名}${后缀名}`)
>
>2. 问题而:问题一解决后用`require后发现出现警告`
>
>   解决:拼接时将后缀名用写死的方式拼接
>
>   ```js
>   requImg = require(`@/img/${url}.png)
>   ```

